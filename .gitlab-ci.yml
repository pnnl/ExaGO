
.pnnllib-gitlab-mirror-container-images:
    # Arguments are passed in environment variables
    # CONTAINERS - Newline seperated list of images to mirror
    # CONTAINERS_FILE - Optional artifact filename which lists the desired images to be cached in a multiline format
    # CONTAINER_CONVERT - define if the images must be converted to store in gitlab
    # CONTAINER_PREFIX - extra prefix for the images. Can be used to add a string on the front of an image name or a parent directory in the repository.
    # RETAG - Change the tag or sha of the image. to rename the image from foo:bar to foo:baz, set to "\1:baz"
    # SOURCE_USERNAME - Optional username to use for download
    # SOURCE_PASSWORD - Optional password to use for download
    image: docker.io/kfox1111/misc:skopeo
    script:
    - |
      set -e
      mkdir -p /etc/gitlab-runner/certs/
      export EXTRA_FLAGS=""
      [ "x$CONTAINERS_FILE" != "x" ] && export CONTAINERS="$(cat $CONTAINERS_FILE)"
      [ "x$SOURCE_USERNAME" != "x" -o "x$SOURCE_PASSWORD" != "x" ] && export EXTRA_FLAGS="--src-creds ${SOURCE_USERNAME}:${SOURCE_PASSWORD}"
      echo "Mirroring: $CONTAINERS"
      echo "$CONTAINERS" | while read IMAGE; do
        [ "x$IMAGE" == "x" ] && continue
        NEWNAME=$(echo "$IMAGE" | sed 's@.*/@@g')
        [ "x$RETAG" == "x" ] || NEWNAME=$(echo "$NEWNAME" | sed 's/^\([^@:]*\)\([:@]\)\(.*\)/'"$RETAG"'/')
        mkdir -p /tmp/containers/"$NEWNAME"
        echo Mirroring "$IMAGE" to "$NEWNAME"
        if [ "x$CONTAINER_CONVERT" != "x" ]; then
          set +e
          skopeo inspect \
            docker://"${CI_REGISTRY_IMAGE}/${CONTAINER_PREFIX}$NEWNAME" \
            --raw \
            --cert-dir /etc/gitlab-runner/certs/ \
            --creds "gitlab-ci-token:$CI_JOB_TOKEN" \
            > /dev/null && echo already exists && continue
          set -xe
          skopeo copy $EXTRA_FLAGS \
            --format v2s2 \
            docker://"$IMAGE" \
            dir:/tmp/containers/"$NEWNAME"
          skopeo copy \
            --dest-cert-dir /etc/gitlab-runner/certs/ \
            --dest-creds "gitlab-ci-token:$CI_JOB_TOKEN" \
            dir:/tmp/containers/"$NEWNAME" \
            docker://"${CI_REGISTRY_IMAGE}/${CONTAINER_PREFIX}$NEWNAME"
        else
          skopeo copy \
            docker://"$IMAGE" $EXTRA_FLAGS  \
            --dest-cert-dir /etc/gitlab-runner/certs/ \
            --dest-creds "gitlab-ci-token:$CI_JOB_TOKEN" \
            docker://"${CI_REGISTRY_IMAGE}/${CONTAINER_PREFIX}$NEWNAME"
        fi
      done

# Deprecated. switch to .pnnllib-gitlab-mirror-chart-to-repo instead
.pnnllib-gitlab-mirror-chart-to-image:
    # CHART - Name of the chart to mirror
    # REPO - Repository URL to mirror from
    # VERSION - Optional helm chart version to pull
    # CONTAINER_PREFIX - extra prefix for the images. Can be used to add a string on the front of an image name or a parent directory in the repository.
    # PATCH - Optional patch to apply to the chart
    # PATCHLEVEL - Optional patch level to patch. Default 1.
    image:
      name: lachlanevenson/k8s-helm:v3.2.1
      entrypoint: [""]
    script:
    - |
      set -e

      #Copy cert into the ca trust store so that helm chart push will work. (Alpine)
      if [ -f /etc/gitlab-runner/certs/ca.crt ]; then
        cat /etc/gitlab-runner/certs/ca.crt > /usr/local/share/ca-certificates/self.crt
        update-ca-certificates
      fi

      helm repo add myrepo "$REPO"
      helm repo update

      echo Pulling chart.
      if [ "x$VERSION" != "x" ]; then
        helm pull myrepo/"$CHART" --untar --version "$VERSION"
      else
        helm pull myrepo/"$CHART" --untar
      fi

      if [ "x$PATCH" != "x" ]; then
        echo Patching chart
        cd "$CHART"
        PATCHLEVEL="${PATCHLEVEL:-1}"
        patch -p"$PATCHLEVEL" < "../$PATCH"
        cd ..
      fi
      echo Uploading
      VERSION=$(helm show chart "$CHART" | awk '/^version:/{print $2}')
      export HELM_EXPERIMENTAL_OCI=1
      echo "$CI_REGISTRY_PASSWORD" | helm registry login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
      helm chart save "$CHART" "$CI_REGISTRY_IMAGE$CONTAINER_PREFIX:$VERSION"
      helm chart push "$CI_REGISTRY_IMAGE$CONTAINER_PREFIX:$VERSION"
      echo This function is deprecated. Please switch your pipeline to use .pnnllib-gitlab-mirror-chart-to-repo instead.

.pnnllib-gitlab-mirror-chart-to-repo:
    # CHART - Name of the chart to mirror
    # REPO - Repository URL to mirror from
    # VERSION - Optional helm chart version to pull
    # CONTAINER_PREFIX - extra prefix for the images. Can be used to add a string on the front of an image name or a parent directory in the repository.
    # PATCH - Optional patch to apply to the chart
    # PATCHLEVEL - Optional patch level to patch. Default 1.
    image:
      name: lachlanevenson/k8s-helm:v3.8.1
      entrypoint: [""]
    script:
    - |
      set -e
      mkdir -p .chartmirror/charts
      cd .chartmirror
      #Copy cert into the ca trust store so that helm chart push will work. (Alpine)
      if [ -f /etc/gitlab-runner/certs/ca.crt ]; then
        cat /etc/gitlab-runner/certs/ca.crt > /usr/local/share/ca-certificates/self.crt
        update-ca-certificates
      fi
      helm repo add myrepo "$REPO"
      helm repo update
      echo Pulling chart.
      if [ "x$VERSION" != "x" ]; then
        helm pull myrepo/"$CHART" --untar --version "$VERSION"
      else
        helm pull myrepo/"$CHART" --untar
      fi
      if [ "x$PATCH" != "x" ]; then
        echo Patching chart
        cd "$CHART"
        PATCHLEVEL="${PATCHLEVEL:-1}"
        patch -p"$PATCHLEVEL" < "../$PATCH"
        cd ..
      fi
      echo Uploading
      helm package "$CHART" -d charts
      echo "${CI_JOB_TOKEN}" | helm registry login --username gitlab-ci-token --password-stdin "${CI_REGISTRY}"
      helm push charts/* "oci://${CI_REGISTRY_IMAGE}${CONTAINER_PREFIX}"

.pnnllib-gitlab-verify-new-image:
    # Verify that the image doesn't already exist
    # Arguments are passed in environment variables
    # CONTAINER_PREFIX - extra prefix for the image. Can be used to add a string on the front of an image name or a parent directory in the repository.
    # CONTAINER_TAG - The container tag to use. Defaults to $CI_COMMIT_TAG
    image: docker.io/kfox1111/misc:skopeo
    script:
    - |
        set -e
        CONTAINER_TAG="${CONTAINER_TAG:-$CI_COMMIT_TAG}"
        mkdir -p /etc/gitlab-runner/certs
        skopeo inspect \
            docker://"$CI_REGISTRY_IMAGE${CONTAINER_PREFIX}:${CONTAINER_TAG}" \
            --raw \
            --cert-dir /etc/gitlab-runner/certs/ \
            --creds "gitlab-ci-token:$CI_JOB_TOKEN" \
           > /dev/null && echo "Image already exists. Please bump version." && exit 1
        exit 0

.pnnllib-gitlab-build-container-image:
    # Build an image using Kaniko
    # Arguments are passed in environment variables
    # CONTAINER_PREFIX - extra prefix for the image. Can be used to add a string on the front of an image name or a parent directory in the repository.
    # CONTAINER_TAG - The container tag to use. Defaults to $CI_COMMIT_TAG
    # DOCKERFILE - The name of the dockerfile to use. Defaults to Dockerfile.
    # KANIKO_EXTRA_ARGS - Extra arguments passed to Kaniko. Example, `--build-arg MY_BUILD_VAR=foo`.
    # HTTP_PROXY - optional, proxy to use and pass when a http proxy is needed.
    # HTTPS_PROXY - optional, proxy to use and pass when a https proxy is needed.
    # NO_PROXY - optional, proxy settings to use and pass when a proxy shouldn't be used
    image:
      name: gcr.io/kaniko-project/executor:debug
      entrypoint: [""]
    script:
    - mkdir -p /kaniko/.docker
    - |-
      KANIKOPROXYBUILDARGS=""
      KANIKOCFG="{\"auths\":{\"$CI_REGISTRY\":{\"auth\":\"$(echo -n ${CI_REGISTRY_USER}:${CI_REGISTRY_PASSWORD} | base64)\"}}}"
      if [ "x${HTTP_PROXY}" != "x" -o "x${HTTPS_PROXY}" != "x" ]; then
        KANIKOCFG="${KANIKOCFG}, \"proxies\": { \"default\": { \"httpProxy\": \"${HTTP_PROXY}\", \"httpsProxy\": \"${HTTPS_PROXY}\", \"noProxy\": \"${NO_PROXY}\"}}"
        KANIKOPROXYBUILDARGS="--build-arg http_proxy=${HTTP_PROXY} --build-arg HTTP_PROXY=${HTTP_PROXY} --build-arg no_proxy=${NO_PROXY}"
      fi
      KANIKOCFG="${KANIKOCFG} }"
      echo "${KANIKOCFG}" > /kaniko/.docker/config.json
      if [ -f /etc/gitlab-runner/certs/ca.crt ]; then
        cat /etc/gitlab-runner/certs/ca.crt >> /kaniko/ssl/certs/ca-certificates.crt
      fi
      DOCKERFILE="${DOCKERFILE:-Dockerfile}"
      CONTAINER_TAG="${CONTAINER_TAG:-$CI_COMMIT_TAG}"
      KANIKO_EXTRA_ARGS="${KANIKO_EXTRA_ARGS:-}"
      /kaniko/executor $KANIKOPROXYBUILDARGS --context "$CI_PROJECT_DIR" --dockerfile "$CI_PROJECT_DIR/$DOCKERFILE" --destination "$CI_REGISTRY_IMAGE${CONTAINER_PREFIX}:$CONTAINER_TAG" $KANIKO_EXTRA_ARGS

.pnnllib-gitlab-load-deploy-token:
    # Load a gitlab deploy token into Kubernetes
    #
    # You must have already created a deploy token with just 'read_registry'
    # permission named 'gitlab-deploy-token', with username 'gitlab-deploy-token' as described here:
    # https://docs.gitlab.com/ee/user/project/deploy_tokens/#creating-a-deploy-token
    #
    # Arguments are passed in environment variables
    #
    # SECRET_NAME - Which secret to load the deploy token into. Defautls to gitlab-registry-token
    image: bitnami/kubectl:1.15.3
    script:
    - |
      SECRET_NAME="${SECRET_NAME:-gitlab-registry-token}"
      if [ "x$CI_DEPLOY_USER" == "x" -o "x$CI_DEPLOY_PASSWORD" == "x" ]; then
        echo A valid deploy token was not found.
        echo
        echo This is very likely because the deploy token was not manually configured in gitlab or the configuration documentation was not followed precisely.
        echo The config is sensitive to the username in particular being set correctly and that it is a deploy token, not a personal or project access token.
        echo
        echo Instructions:
        echo Create a deploy token with just "'read_registry'" permission named "'gitlab-deploy-token'", with username "'gitlab-deploy-token'" as described here:
        echo https://docs.gitlab.com/ee/user/project/deploy_tokens/#creating-a-deploy-token
        exit -1
      fi
      kubectl create secret docker-registry "$SECRET_NAME" --docker-server="$CI_REGISTRY" --docker-username="$CI_DEPLOY_USER" --docker-password="$CI_DEPLOY_PASSWORD" --dry-run -o yaml | kubectl apply -f -

# CI constraints for every branch
workflow:
  rules:
      # Only run if source is an open merge request or a branch push
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: '$CI_COMMIT_BRANCH'

.ornl_script_template: &ornl_script_definition
  script:
    - |
      # Do _not_ clean up WORKDIR as files are needed for testing
      set -xv
      mkdir -p "$WORKDIR"
      cp -R ./* "$WORKDIR"
      cd "$WORKDIR"
      export srcdir=$WORKDIR builddir=$WORKDIR/build installdir=$WORKDIR/install
      MY_CLUSTER=ascent ./buildsystem/build.sh --build-only --job=gcc-cuda || exit 1

.ornl_test_script_template: &ornl_test_script_definition
  script:
    - |
      set -xv
      cd "$WORKDIR"
      export srcdir=$WORKDIR builddir=$WORKDIR/build installdir=$WORKDIR/install

      # Export CTESTARGS defined in variables to run correct tests for stage
      export CTESTARGS="--output-on-failure -E Python"

      MY_CLUSTER="ascent" ./buildsystem/build.sh --test-only --job=gcc-cuda
      res=$?
      exit $res
  # Only running after_script for 
  after_script:
    - |
      cd "$WORKDIR/.."
      rm -rf "$WORKDIR"

  
.ornl_python_test_script_template: &ornl_python_test_script_definition
  script:
    - |
      set -xv
      cd "$WORKDIR"
      export srcdir=$WORKDIR builddir=$WORKDIR/build installdir=$WORKDIR/install

      # Export CTESTARGS defined in variables to run correct tests for stage
      export CTESTARGS="-VV -R Python"

      MY_CLUSTER="ascent" ./buildsystem/build.sh --test-only --job=gcc-cuda
      res=$?
      exit $res

.ornl_environment_template: &ornl_environment_variables
  variables:
    SCHEDULER_PARAMETERS: "-P CSC359 -nnodes 1 -W 120"
    WORKDIR: /gpfs/wolf/proj-shared/csc359/ci/${CI_PIPELINE_ID}

.pnnl_after_script_template: &pnnl_after_script_definition
  after_script:
    - |
      export WORKDIR="$HOME/gitlab/${CI_PIPELINE_ID}/${MY_CLUSTER}/"
      # Iterate over possible jobid named files (jobid_%J)
      job_ids="$WORKDIR/jobid_*"
      for job in $job_ids
      do
        if [[ -f "$job" ]]; then
          jobid=$(cat "$job")
          scancel $jobid
        fi
      done
      rm -rf $WORKDIR

.pnnl_script_template: &pnnl_script_definition
  script:
    - |
      # pass --verbose to build.sh for verbose debugging
      #
      #  NOTES:  WORKDIR is on constance/marianas/newell
      #          ./      is only on the Kubernetes instance
      #
      export WORKDIR="$HOME/gitlab/${CI_PIPELINE_ID}/${WORKDIR_SUFFIX}/"
      if [[ ! -d "$WORKDIR" ]]; then
        # if workdir already exists, we're in the testing job
        mkdir -p "$WORKDIR"
        cp -R ./* "$WORKDIR"
        cp ./.cmake-format.py "$WORKDIR"
      fi

      if [[ $MY_CLUSTER = "marianas" ]]; then
        export SLURM_Q=`perl ./buildsystem/pnnl/findIdleDLNodes.pl`
      else
        export SLURM_Q=`perl ./buildsystem/pnnl/findIdleNewellNodes.pl`
      fi

      cd "$WORKDIR"
      # Unique output file for this stage
      output="output${OUTPUT_SUFFIX}"
      [ -f $output ] && rm $output
      touch $output
      tail -f $output &
      tailpid=$!

      # Set some directories used in the build script manually, as they
      # can be inconsistent in gitlab pipelines
      export srcdir=$WORKDIR builddir=$WORKDIR/build installdir=$WORKDIR/install

      # Export CTESTARGS defined in variables to run correct tests for stage
      export CTESTARGS=$CTESTARGS

      # jobid used in pnnl_after_script_template to cancel job if cancelled or
      # timed out by gitlab through the UI
      jobid=$(sbatch --export=ALL -A EXASGD --gres=gpu:1 --ntasks=3 -p $SLURM_Q -o $output -e $output -t 1:00:00 $WORKDIR/buildsystem/build.sh $SCRIPT_ARGS)
      export jobid=$(echo $jobid | cut -f4 -d' ')
      # Unique jobid filename for this job
      echo $jobid > "$WORKDIR/jobid_${jobid}"
      res=1
      while :;
      do
        if [[ "$(awk 'BEGIN{i=0}/BUILD_STATUS/{i++}END{print i}' $output)" != "0" ]]; then
          kill $tailpid
          echo 'Last tail of build output:'
          tail -n 200 $output
          res=$(grep BUILD_STATUS $output | tail -n 1 | cut -f2 -d':')
          break
        fi
        sleep 10
      done
      echo "Finished batch job with exit code: $res"
      rm "$WORKDIR/jobid_${jobid}"
      exit $res

.pnnl_tags_template: &pnnl_tags_definition
  tags:
    - k8s
    - ikp
    - exasgd
    - marianas

.pnnl-rules: &pnnl-rules
  rules:
    - &pnnl-rule
      if: '$CI_PROJECT_ROOT_NAMESPACE == "exasgd"' # Will only apply to PNNL

.pnnl-nonhpc-tags: &pnnl-nonhpc-definition
  tags:
    - k8s
    - ikp
    - exasgd
    - basic

variables:
  GIT_SUBMODULE_STRATEGY: recursive

stages:
  - build
  - test

# Include PNNL GitLab stdlib
# include:
#   - remote: 'https://raw.githubusercontent.com/pnnl-miscscripts/gitlab-lib/v1/gitlab-lib.yaml'

# For Crusher CI
.crusher-rules: &crusher-rules
  rules:
    - if: '$CI_PIPELINE_SOURCE == "web"'
    - when: never

.crusher-variables: &crusher-variables
  # Only for slurm tagged jobs...
  variables:
    SCHEDULER_PARAMETERS: "-N 1 -A CSC359 --time=60"
    WORKDIR: /gpfs/alpine/csc359/proj-shared/ci/${CI_PIPELINE_ID}

Crusher Build:
  stage: build
  tags: [crusher, shell]
  script:
    - mkdir -p "$WORKDIR"
    - cp -R ./* "$WORKDIR"
    - cd "$WORKDIR"
    - export srcdir=$WORKDIR builddir=$WORKDIR/build installdir=$WORKDIR/install
    - MY_CLUSTER=crusher ./buildsystem/build.sh --build-only --job=clang-hip
    - res=$?
    - exit $res
  <<: *crusher-rules
  <<: *crusher-variables
  
Crusher Test:
  stage: test
  dependencies:
    - "Crusher Build"
  tags: [crusher, slurm]
  script:
    - cd "$WORKDIR"
    - export srcdir=$WORKDIR builddir=$WORKDIR/build installdir=$WORKDIR/install
    - export CTESTARGS="--output-on-failure -E Python"
    - MY_CLUSTER=crusher ./buildsystem/build.sh --test-only --job=clang-hip
    - res=$?
    - exit $res
  after_script:
    - cd "$WORKDIR/.."
    - rm -rf "$WORKDIR"
  <<: *crusher-rules
  <<: *crusher-variables

Crusher Python Test:
  stage: test
  dependencies: 
    - "Crusher Build"
  allow_failure: true
  tags: [crusher, slurm]
  script:
    - cd "$WORKDIR"
    - export srcdir=$WORKDIR builddir=$WORKDIR/build installdir=$WORKDIR/install
    - export CTESTARGS="--output-on-failure -R Python"
    - MY_CLUSTER=crusher ./buildsystem/build.sh --test-only --job=clang-hip
    - res=$?
    - exit $res
  <<: *crusher-rules
  <<: *crusher-variables
# ---

# For Ascent CI
.ornl-rules: &ornl-rules
  rules:
    - if: '$CI_PROJECT_PATH == "ecpcitest/exasgd/exago"'

Ascent Build:
  stage: build
  tags:
    - nobatch
  <<: *ornl-rules
  <<: *ornl_script_definition
  <<: *ornl_environment_variables

Ascent Test:
  stage: test
  dependencies:
    - 'Ascent Build'
  tags:
    - batch
  variables:
    CTESTARGS: "--output-on-failure -E Python"
  <<: *ornl-rules
  <<: *ornl_test_script_definition
  <<: *ornl_environment_variables

Ascent Py Test:
  stage: test
  dependencies:
    - 'Ascent Build'
  tags:
    - batch 
  variables:
  <<: *ornl-rules
  <<: *ornl_python_test_script_definition
  <<: *ornl_environment_variables
  allow_failure: true
# ---

# For PNNL CI
.pnnl-nonhpc-tags: &pnnl-nonhpc-definition
  tags:
    - k8s
    - ikp
    - exasgd
    - basic

CMake Lint:
  stage: build
  allow_failure: true
  <<: *pnnl-nonhpc-definition
  <<: *pnnl-rules
  image: ubuntu:20.04
  script:
    |
    set -x
    apt update && apt install -y python3 python3-pip perl
    pip install cmake_format
    ./buildsystem/tools/cmake_format.pl -v
    exit $?

C++ Lint:
  stage: build
  allow_failure: true
  <<: *pnnl-nonhpc-definition
  <<: *pnnl-rules
  image: ubuntu:20.04
  script:
    |
    set -x
    apt update && apt install -y clang-format perl
    ./buildsystem/tools/clang_format.pl -v
    exit $?

Python Lint:
  stage: build
  allow_failure: true
  <<: *pnnl-nonhpc-definition
  <<: *pnnl-rules
  image: ubuntu:20.04
  script:
    |
    set -x
    apt update && apt install -y python3 python3-pip perl
    pip install pycodestyle autopep8
    ./buildsystem/tools/python_format.pl -v
    exit $?

File Naming Conventions:
  stage: build
  allow_failure: true
  <<: *pnnl-nonhpc-definition
  <<: *pnnl-rules
  image: ubuntu:20.04
  script:
    |
    set -x
    apt update && apt install -y perl
    ./buildsystem/tools/file_naming_conventions.pl
    exit $?

SVC Account Cleanup:
  stage: .pre
  <<: *pnnl-rules
  <<: *pnnl_tags_definition
  rules:
    - if: '$CI_COMMIT_MESSAGE =~ /\[cleanup\]/'

  script:
    - cd /people/svcexasgd/ && rm -rf gitlab/*

Newell Build:
  stage: build
  variables:
    SLURM_Q: "newell_shared"
    MY_CLUSTER: "newell"
    OUTPUT_SUFFIX: "_build"
    SCRIPT_ARGS: " --build-only --job=gcc-cuda "
    WORKDIR_SUFFIX: "ppc64le-gcc-cuda-build"
  <<: *pnnl_tags_definition
  <<: *pnnl_script_definition
  <<: *pnnl-rules

Newell Test:
  stage: test
  dependencies:
    - 'Newell Build'
  variables:
    SLURM_Q: "newell_shared"
    MY_CLUSTER: "newell"
    CTESTARGS: "--output-on-failure -E Python"
    OUTPUT_SUFFIX: "_test"
    SCRIPT_ARGS: " --test-only --job=gcc-cuda "
    WORKDIR_SUFFIX: "ppc64le-gcc-cuda-build"
  <<: *pnnl_tags_definition
  <<: *pnnl_script_definition
  <<: *pnnl_after_script_definition
  <<: *pnnl-rules

Marianas Build:
  stage: build
  variables:
    SLURM_Q: "dl_shared"
    MY_CLUSTER: "marianas"
    OUTPUT_SUFFIX: "_build"
    SCRIPT_ARGS: " --build-only --job=gcc-cuda "
    WORKDIR_SUFFIX: "x86_64-gcc-cuda-build"
  <<: *pnnl_tags_definition
  <<: *pnnl_script_definition
  <<: *pnnl-rules

Marianas Test:
  stage: test
  dependencies:
    - 'Marianas Build'
  variables:
    SLURM_Q: "dl_shared"
    MY_CLUSTER: "marianas"
    CTESTARGS: "--output-on-failure -E Python"
    OUTPUT_SUFFIX: "_test"
    SCRIPT_ARGS: " --test-only --job=gcc-cuda "
    WORKDIR_SUFFIX: "x86_64-gcc-cuda-build"
  <<: *pnnl_tags_definition
  <<: *pnnl_script_definition
  <<: *pnnl_after_script_definition
  <<: *pnnl-rules

Newell Py Test:
  stage: test
  dependencies:
    - 'Newell Build'
  variables:
    SLURM_Q: "newell_shared"
    MY_CLUSTER: "newell"
    CTESTARGS: "--output-on-failure -R Python"
    OUTPUT_SUFFIX: "_test_python"
    SCRIPT_ARGS: " --test-only --job=gcc-cuda "
    WORKDIR_SUFFIX: "ppc64le-gcc-cuda-build"
  <<: *pnnl_tags_definition
  <<: *pnnl_script_definition
    # No after_script as only one test per platform cleans up
  <<: *pnnl-rules
  allow_failure: true

Marianas Py Test:
  stage: test
  dependencies:
    - 'Marianas Build'
  variables:
    SLURM_Q: "dl_shared"
    MY_CLUSTER: "marianas"
    CTESTARGS: "--output-on-failure -R Python"
    OUTPUT_SUFFIX: "_test_python"
    SCRIPT_ARGS: " --test-only --job=gcc-cuda "
    WORKDIR_SUFFIX: "x86_64-gcc-cuda-build"
  <<: *pnnl_tags_definition
  <<: *pnnl_script_definition
    # No after_script as only one test per platform cleans up
  <<: *pnnl-rules
  allow_failure: true
# ---

