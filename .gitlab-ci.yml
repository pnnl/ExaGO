
# CI constraints for every branch
workflow:
  rules:
      # Only run if source is an open merge request or a branch push
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: '$CI_COMMIT_BRANCH'

.ornl_script_template: &ornl_script_definition
  script:
    - |
      # Do _not_ clean up WORKDIR as files are needed for testing
      set -xv
      mkdir -p "$WORKDIR"
      cp -R ./* "$WORKDIR"
      cd "$WORKDIR"
      export srcdir=$WORKDIR builddir=$WORKDIR/build installdir=$WORKDIR/install
      MY_CLUSTER=ascent ./buildsystem/build.sh --build-only --job=gcc-cuda || exit 1

.ornl_test_script_template: &ornl_test_script_definition
  script:
    - |
      set -xv
      cd "$WORKDIR"
      export srcdir=$WORKDIR builddir=$WORKDIR/build installdir=$WORKDIR/install
      MY_CLUSTER="ascent" ./buildsystem/build.sh --test-only --job=gcc-cuda
      res=$?
      exit $res
  after_script:
    - |
      cd "$WORKDIR/.."
      rm -rf "$WORKDIR"

.ornl_environment_template: &ornl_environment_variables
  variables:
    SCHEDULER_PARAMETERS: "-P CSC359 -nnodes 1 -W 30"
    WORKDIR: /gpfs/wolf/proj-shared/csc359/ci/${CI_PIPELINE_ID}

.pnnl_after_script_template: &pnnl_after_script_definition
  after_script:
    - |
      exit 0
      export WORKDIR="$HOME/gitlab/${CI_PIPELINE_ID}/${MY_CLUSTER}/"
      # Iterate over possible jobid named files (jobid_%J)
      job_ids="$WORKDIR/jobid_*"
      for job in $job_ids
      do
        if [[ -f "$job" ]]; then
          jobid=$(cat "$job")
          scancel $jobid
        fi
      done
      rm -rf $WORKDIR

.pnnl_script_template: &pnnl_script_definition
  script:
    - |
      exit 0
      set -xv
      #
      #  NOTES:  WORKDIR is on constance/marianas/newell
      #          ./      is only on the Kubernetes instance
      #
      export WORKDIR="$HOME/gitlab/${CI_PIPELINE_ID}/${WORKDIR_SUFFIX}/"
      if [[ ! -d "$WORKDIR" ]]; then
        # if workdir already exists, we're in the testing job
        mkdir -p "$WORKDIR"
        cp -R ./* "$WORKDIR"
        cp ./.cmake-format.py "$WORKDIR"
      fi

      if [[ $MY_CLUSTER = "marianas" ]]; then
        export SLURM_Q=`perl ./buildsystem/pnnl/findIdleDLNodes.pl`
      else
        export SLURM_Q=`perl ./buildsystem/pnnl/findIdleNewellNodes.pl`
      fi

      cd "$WORKDIR"
      # Unique output file for this stage
      output="output_${OUTPUT_SUFFIX}"
      [ -f $output ] && rm $output
      touch $output
      tail -f $output &
      tailpid=$!

      # Set some directories used in the build script manually, as they
      # can be inconsistent in gitlab pipelines
      export srcdir=$WORKDIR builddir=$WORKDIR/build installdir=$WORKDIR/install

      # Export CTESTARGS defined in variables to run correct tests for stage
      export CTESTARGS=$CTESTARGS

      # jobid used in pnnl_after_script_template to cancel job if cancelled or
      # timed out by gitlab through the UI
      jobid=$(sbatch --export=ALL -A EXASGD --gres=gpu:1 --ntasks=2 -p $SLURM_Q -o $output -e $output -t 1:00:00 $WORKDIR/buildsystem/build.sh $SCRIPT_ARGS)
      export jobid=$(echo $jobid | cut -f4 -d' ')
      # Unique jobid filename for this job
      echo $jobid > "$WORKDIR/jobid_${jobid}"
      res=1
      while :;
      do
        if [[ "$(awk 'BEGIN{i=0}/BUILD_STATUS/{i++}END{print i}' $output)" != "0" ]]; then
          kill $tailpid
          echo 'Last tail of build output:'
          tail -n 50 $output
          res=$(grep BUILD_STATUS $output | tail -n 1 | cut -f2 -d':')
          break
        fi
        sleep 10
      done
      echo "Finished batch job with exit code: $res"
      rm "$WORKDIR/jobid_${jobid}"
      exit $res

.pnnl_tags_template: &pnnl_tags_definition
  tags:
    - k8s
    - ikp
    - exasgd
    - marianas

.pnnl_rules_template: &pnnl_rules_definition
  rules:
    - if: '$CI_PROJECT_ROOT_NAMESPACE == "exasgd"' # Will only apply to PNNL

.pnnl-nonhpc-tags: &pnnl-nonhpc-definition
  tags:
    - k8s
    - ikp
    - exasgd
    - basic

stages:
  #- build
  #- test
  - spack-generate
  - spack-build

# Include PNNL GitLab stdlib
include:
  - remote: 'https://raw.githubusercontent.com/pnnl-miscscripts/gitlab-lib/v1/gitlab-lib.yaml'

.spack-parallel: &spack-parallel-def
  parallel:
    matrix:
      - ENVIRONMENT: [exago-develop-hiop-0.4.1, exago-develop]

spack-generate-job:
  <<: *pnnl_rules_definition
  stage: spack-generate
  image: perl
    # rules:
    #   - if: $CI_COMMIT_BRANCH == "develop"
    #   - if: $CI_PIPELINE_SOURCE == "schedule"
    #   - when: manual
  tags: [k8s, ikp, exasgd, basic]
  artifacts:
    paths:
      - "*.Dockerfile"
  script:
    - |
      set -x
      args=""; export args
      if [ ! "x${REBUILD_SPACK_BUILDCACHE}" = "x0" ]; then
        args=" -c "; export args
      fi
      for spackenv in $(find buildsystem/container/environments/ -name '*.yaml'); do
        cp $spackenv ./spack.yaml
        ./buildsystem/container/containerize.pl $args > "${ENVIRONMENT}.Dockerfile"
      done

spack-build-job:
  <<: *spack-parallel-def
  <<: *pnnl_rules_definition
  stage: spack-build
  tags: [k8s, ikp, exasgd, basic]
  variables:
    KANIKO_EXTRA_ARGS: --single-snapshot
    CONTAINER_TAG: $ENVIRONMENT
  extends:
    - .pnnllib-gitlab-build-container-image
  needs:
    - job: spack-generate-job
      artifacts: true
  before_script:
    - cp "${ENVIRONMENT}.Dockerfile" Dockerfile

# For Ascent CI
#build_on_login_node:
#  stage: build
#  tags:
#    - nobatch
#  rules:
#    - if: '$CI_PROJECT_PATH == "ecpcitest/exasgd/exago"'
#  <<: *ornl_script_definition
#  <<: *ornl_environment_variables
#
#test_on_compute_node:
#  stage: test
#  dependencies:
#    - build_on_login_node
#  tags:
#    - batch
#  rules:
#    - if: '$CI_PROJECT_PATH == "ecpcitest/exasgd/exago"'
#  <<: *ornl_test_script_definition
#  <<: *ornl_environment_variables
#
# ---

# For PNNL CI
#cmake-lint:
#  stage: build
#  allow_failure: true
#  <<: *pnnl-nonhpc-definition
#  <<: *pnnl_rules_definition
#  image: ubuntu:20.04
#  script:
#    |
#    set -x
#    apt update && apt install -y python3 python3-pip ack
#    pip install cmake_format
#    ret=0
#    for f in $(ack -f --type cmake); do
#      cmake-format --log-level info --check $f
#      ret=$(($ret + $?))
#    done
#    exit $ret
#
#ppc64le-gcc-cuda-build:
#  stage: build
#  variables:
#    SLURM_Q: "newell_shared"
#    MY_CLUSTER: "newell"
#    OUTPUT_SUFFIX: "_build"
#    SCRIPT_ARGS: " --build-only --job=gcc-cuda "
#    WORKDIR_SUFFIX: "ppc64le-gcc-cuda-build"
#  <<: *pnnl_tags_definition
#  <<: *pnnl_script_definition
#  <<: *pnnl_rules_definition
#
#ppc64le-gcc-cuda-test:
#  stage: test
#  dependencies:
#    - ppc64le-gcc-cuda-build
#  variables:
#    SLURM_Q: "newell_shared"
#    MY_CLUSTER: "newell"
#    CTESTARGS: "-VV -E Python"
#    OUTPUT_SUFFIX: "_test"
#    SCRIPT_ARGS: " --test-only --job=gcc-cuda "
#    WORKDIR_SUFFIX: "ppc64le-gcc-cuda-build"
#  <<: *pnnl_tags_definition
#  <<: *pnnl_script_definition
#  <<: *pnnl_after_script_definition
#  <<: *pnnl_rules_definition
#
#ppc64le-gcc-cuda-python-test:
#  stage: test
#  dependencies:
#    - ppc64le-gcc-cuda-build
#  variables:
#    SLURM_Q: "newell_shared"
#    MY_CLUSTER: "newell"
#    CTESTARGS: "-VV -R Python"
#    OUTPUT_SUFFIX: "_test_python"
#    SCRIPT_ARGS: " --test-only --job=gcc-cuda "
#    WORKDIR_SUFFIX: "ppc64le-gcc-cuda-build"
#  <<: *pnnl_tags_definition
#  <<: *pnnl_script_definition
#    # No after_script as only one test per platform cleans up
#  <<: *pnnl_rules_definition
#  allow_failure: true

#x86_64-gcc-cuda-build:
#  stage: build
#  variables:
#    SLURM_Q: "dl_shared"
#    MY_CLUSTER: "marianas"
#    OUTPUT_SUFFIX: "_build"
#    SCRIPT_ARGS: " --build-only --job=gcc-cuda "
#    WORKDIR_SUFFIX: "x86_64-gcc-cuda-build"
#  <<: *pnnl_tags_definition
#  <<: *pnnl_script_definition
#  <<: *pnnl_rules_definition
#
#x86_64-gcc-cuda-test:
#  stage: test
#  dependencies:
#    - x86_64-gcc-cuda-build
#  variables:
#    SLURM_Q: "dl_shared"
#    MY_CLUSTER: "marianas"
#    CTESTARGS: "-VV -E Python"
#    OUTPUT_SUFFIX: "_test"
#    SCRIPT_ARGS: " --test-only --job=gcc-cuda "
#    WORKDIR_SUFFIX: "x86_64-gcc-cuda-build"
#  <<: *pnnl_tags_definition
#  <<: *pnnl_script_definition
#  <<: *pnnl_after_script_definition
#  <<: *pnnl_rules_definition

#x86_64-gcc-cuda-python-test:
#  stage: test
#  dependencies:
#    - x86_64-gcc-cuda-build
#  variables:
#    SLURM_Q: "dl_shared"
#    MY_CLUSTER: "marianas"
#    CTESTARGS: "-VV -R Python"
#    OUTPUT_SUFFIX: "_test_python"
#    SCRIPT_ARGS: " --test-only --job=gcc-cuda "
#    WORKDIR_SUFFIX: "x86_64-gcc-cuda-build"
#  <<: *pnnl_tags_definition
#  <<: *pnnl_script_definition
#    # No after_script as only one test per platform cleans up
#  <<: *pnnl_rules_definition
#  allow_failure: true
# ---

