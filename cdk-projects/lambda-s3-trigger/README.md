# lambda-s3-trigger

## Goal / Purpose

- Build custom Dockerfile for use in lambda (when using `DockerImageCode.from_image_asset`)
- Eventually, use ECR pre-built image, and have lambda `import exago` and construct OPFLOW object

## Contents

```
.
├── README.md
├── app.py
├── cdk.json
├── lambda
│   ├── Dockerfile
│   ├── lambda_handler.py
│   └── python_wrapper
├── requirements.txt
└── s3trigger
    ├── __init__.py
    ├── __pycache__
    └── s3trigger_stack.py
```

- `finalize_dockerfile.sh`
    - This takes the existing dockerfile generated by `docker_bash.sh`, copies it into the `lambda` folder, and modifies to support lambda invocation
- `app.py`
    - Determines the type of application configured during `cdk-synth`
    - In this case, configured an S3 trigger to run using a Docker image
- `cdk.json`
    - Core configuration for `cdk-synth`, points to `python3 app.py`
- `requirements.txt`
    - Local venv file that ensures the correct version of `aws-cdk-lib` is used
- `s3trigger`
    - `__init__.py`
        - Even though file is empty, it is required
        - Auto-generated, so no need to track this in git?
    - `s3trigger_stack.py`
        - This defines the:
            - Notification that the S3 bucket generates
            - Defines lambda function to be ran
            - If using `DockerImageCode.from_image_asset`, this defines folder where a Dockerfile and configuration live:
                - This configuration is built with a unique name during `cdk-deploy`, and our lambda automatically uses that unique name
            - TODO: If this uses `from_ecr`, then just pulls from existing ecr image
- `lambda`
    - `Dockerfile`
        - Contents to be build if using `DockerImageCode.from_image_asset`
        - Generated by `finalize_dockerfile.sh`
    - `lambda_handler.py`
        - CURRENTLY UNUSED
        - When working, our lambda will call this Python function to handle the trigger
    - `python_wrapper`
        - CURRENTLY UNUSED
        - When working, might include useful utility libraries

## Workflows

1. cdk-synth 
    1. Generates concrete cloud configuration from abstract specification in `.`
1. cdk-deploy
    1. Pushes changes to AWS with updated configuration from `cdk-synth`
1. `finalize_dockerfile.sh`
    1. Make sure that you have:
        1. Checked out the spack submodule
        1. Updated the `spack.yaml` with the exago spec that you need/want
    1. After running this, the Dockerfile is modified to support lambda handler. Here is a snippet of what the Dockerfile looks like when running without ExaGO, and gives a sense of what modifications are necessary and applied in this script:

```Dockerfile
# Amznlinux:2 with Python
FROM public.ecr.aws/lambda/python:3.11
 
ENV LAMBDA_TASK_ROOT /var/root

# Copy function code
RUN mkdir -p ${LAMBDA_TASK_ROOT}
COPY lambda_handler.py ${LAMBDA_TASK_ROOT}

RUN pip install --upgrade pip

# Install the function's dependencies
RUN pip install \
    --target ${LAMBDA_TASK_ROOT} \
        awslambdaric

# Set runtime interface client as default command for the container runtime
ENTRYPOINT [ "/var/lang/bin/python", "-m", "awslambdaric" ]
 
# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
WORKDIR ${LAMBDA_TASK_ROOT}
CMD [ "lambda_handler.main" ]

```
